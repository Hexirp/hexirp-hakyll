# design

設計について。

## 2020-02-20

設計の日記のようなもの。

### coding

今 (2020-02-20) で分かっている範囲でまとめてみる。

```
    Domain Model

Control.Monad.Hexyll
Data.List.Hexyll
Data.Yaml.Hexyll
Hexyll.Core.Configuration
Hexyll.Core.Identifier.Internal
Hexyll.Core.Identifier
Hexyll.Core.Identifier.Pattern.Glob
Hexyll.Core.Identifier.Pattern.Internal
Hexyll.Core.Identifier.Pattern
Hexyll.Core.Identifier.OldPattern
Hexyll.Core.Dependencies.Internal
Hexyll.Core.Dependencies

    Domain Model (Classes for Infrasturecture)

Hexyll.Core.Metadata

    Infrastructure

Hexyll.Core.Logger
Hexyll.Core.Store
```

こんな感じだろうか。

### modeling

コンパイラーとして。

* ユーザーが、
  * ファイル群をコンパイルする。
    * コンパイルの結果はキャッシュとして保存される。
  * コンパイルの結果をクリアする。
    * キャッシュも同時に削除される。
  * 静的解析を行う。
  * デプロイを行う。

コンパイラー作成のためのライブラリーとして。

* ユーザーが、
  * ルールを実行する。
    * コンフィグを渡せる。
  * ルールを組み立てる。
    * パターンで対象となるリソースをフィルタできる。
    * どの位置に配置されるか指定できる。
    * コンパイラを指定できる。
  * コンパイラを組み立てる。
    * 元となるコンパイラをライブラリから引ける。
    * 識別子で指定してテンプレートを読み込める。
    * アイテムにテンプレートを適用できる。
    * コンパイラからアイテムを得られる。
    * 識別子で指定してリソースを読み込める。
    * コンパイラに引数を渡せる。
    * pandoc を使ったコンパイラを使える。
    * テンプレートを適用するだけの特殊なコンパイラを使える。
    * リソースを取得するだけの特殊なコンパイラを使える。
    * CSSを圧縮できるだけの特殊なコンパイラを使える。
  * コンテクストを組み立てられる。
    * それぞれのコンテクストについて情報の得方を指定できる。
  * フィードページを作ることができる。

これらを整理する。

コンパイラーとして。

* ユーザーが、
  * **ファイル群をコンパイルする。**
    * **コンパイルの結果はキャッシュとして保存される。**
  * **コンパイルの結果をクリアする。**
  * **コンパイルの結果とキャッシュをクリアする。**
  * 静的解析を行う（別のライブラリで特殊なコンパイラとして提供する）。
  * <del>デプロイを行う。</del>

コンパイラーを作成するためのライブラリとして。

* ユーザーが、
  * **ルールを実行する。**
    * **コンフィグを渡せる。**
  * **ルールを組み立てる。**
    * **パターンで対象となるリソースをフィルタできる。**
    * **どの位置に配置されるか（ルート）を指定できる。**
    * **コンパイラを指定できる。**
  * **コンパイラを組み立てる。**
    * **元となるコンパイラをライブラリから引ける。**
    * 識別子で指定してテンプレートを読み込める（テンプレートはリソースの一つであるため統合）。
    * アイテムにテンプレートを適用できる（別のライブラリで提供）。
    * コンパイラからアイテムを得られる（？）。
    * **識別子で指定してリソースを読み込める。**
    * **コンパイラに引数を渡せる。**
    * pandoc を使ったコンパイラを使える（別のライブラリで提供）。
    * テンプレートを適用するだけの特殊なコンパイラを使える（別のライブラリで提供）。
    * **リソースを取得するだけの特殊なコンパイラを使える。**
    * CSSを圧縮できるだけの特殊なコンパイラを使える（別のライブラリで提供）。
  * コンテクストを組み立てられる（？）。
    * それぞれのコンテクストについて情報の得方を指定できる（？）。
  * フィードページを作ることができる（別のライブラリで提供）。
  * **新しいサブコマンドを作ることができる。**

こうなった。まだよくわかっていないところがある。

### coding

`Item` と `Context` について理解したい。

識別子、つまり `Identifier` 型は重要である。このライブラリにおけるリソースは全てが `Identifier` により識別されるのだから。

`Hexyll.Core.Logger` と `Hexyll.Core.Store` は、それぞれログとリソースを集約している。これらは依存関係の逆転を行わなければならないだろう。そして、それは ReaderT デザインパターンにより達成できる。ここで IO に限定されるため純粋なモックが作れなさそうに見えるが、一つの可変参照を認めるだけで近いものを作ることができる。

`Hexyll.Core.Metadata` の `MonadMetadata` も集約に関するものである。その実装の一つは store を使って与えられている。

### modeling

追加で。

* ユーザーが、
  * **コンパイラを組み立てる。**
    * **リソースに付随するメタデータを読み込める。**
