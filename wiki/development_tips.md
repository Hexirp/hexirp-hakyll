# tips

hexyll を開発している途中に気づいた簡単な Tips 集。信じたことによる不利益の責任は取らない。

* 容赦なく削除する。
  * 要らない機能は削除しよう。
  * 自分で使うためのツールだからできることだ。
  * 幸い Haskell は型があるので、修正すべきところをすぐに教えてくれる。
* 困難は分割する。
  * パッケージがメモリを使いすぎてビルドできないなら、複数のパッケージに分割する。
  * パッケージに GPL であるべきコードが混入していたら、その部分を別のパッケージに切り出す。
  * Haskell では多様な型の機能と言語拡張で、ほとんどのものを切り出せるようになっている。
* ビルド時のフラグはできるだけ使わない。
  * それよりも二つのパッケージに分離することを考える。
  * デフォルトの状態でビルドできるのは簡単にチェックできる。なら、そうでない時は？
* stack を使う。
  * 複数の GHC でビルドしたいなら stack を使う。
  * 最近は cabal が高機能になってきているが、それでも stack がユーザーフレンドリーなのには変わりない。
* stack resolver を使う。
  * 依存するパッケージのバージョンに幅を持たせたいときに、とても有効な基準になる。
* hpack を使う。
  * モジュールのファイルを作るだけでパッケージに含まれるようになるのは、細かいことだがストレスがない。
  * モジュールを移動した時もいちいち cabal ファイルを変えに行く必要がなくなる。
  * 以上のことはフォーマッタなどでも実現することができるが、それでも stack を使えば自動的に使えて簡便なのは変わりないし、さらに yaml という一般的な形式を使えるのも良い。
* cryptonite を使う。
  * 暗号学的ハッシュを使いたいときはこれだ。
  * cryptohash は非推奨になった。代替として挙げられているのがこれだ。
  * basement と memory と cryptonite とグループになっているのも良いところだ。
* コードは定期的に掃除する。
  * 例えば GHC のバージョンを変えるときに清掃しよう。
  * 古い base のバージョンに対応するための CPP や、変更によって不要になっている言語拡張の指定を見るのはもうたくさんだ。
* Windows でもビルドする。
  * 実際に Windows で使ってみるのが非互換性を見つける一番良い方法である。
* テストは愚直に書く。
  * テストへ自動的に番号を割り振るクールな関数だって？　どんな内容のテストで失敗したのか分からなくしたいのか。おまけに関数の中で `printf` を使っているしな。
* IDE を使う。
  * モジュールや関数の名前を変更するたびに Vim で `:%s/.../.../` と `:wn` を繰り返し打ち続けるのは苦行だ。
* path パッケージを使う。
  * `FilePath` 型ではなく `Path` 型を使う。
  * このパッケージは幽霊型の最も役に立つ例だと断言したいくらい便利だ。幽霊型が出しゃばりすぎていない。本当に必要な性質だけを幽霊型で表している。
* binary のドキュメントは少ないことを覚悟しておく。
  * `Binary` 型クラスのインスタンスの書き方は、公式ドキュメントで一回だけ触れられるだけだ。しかしも、それらに使われる `Put` 型と `Get` 型が `Alternative` 型クラスになっていることは言及してくれない。そして、その `empty` が失敗を表すことは内部実装を読むことでしか知れない。
* 予想する原因の中に単純な間違いを常に入れておく。
  * タイポ、インポート忘れ、型の変え忘れ、名前の変え忘れ、引数の渡し忘れ、……
* 型を設計に使う。
  * Haskell なら基本である。
  * 型を考え始めた途端に関数の定義の見通しが良くなる。
* 綺麗な設計が見つからないときは、仮の設計をしておいて、綺麗な設計が見つかるまで待つ。
  * 初めは Hexyll.Core.Identifier.Pattern をどのようにリファクタリングすればいいか分からなかった。なので https://github.com/Hexirp/hexirp-hakyll/pull/68 のように仮の設計を加えた。どのように使われているかを調査したら良い設計を見つけ出すことができた。その結果が https://github.com/Hexirp/hexirp-hakyll/pull/70 である。
* A から B を生成する関数は基本的に B のモジュールに置く。
  * 何を生成するかは変わらないことが多いけど何から生成するかは変わることが多い。
  * もちろん、何を生成するかが変わりやすいと予想できる場合は A のモジュールへ。
  * `PatternExpr` 型も `from***` みたいな関数がたくさん。
* `mempty` はモノイドの文脈の所だけで使う。
  * `empty` などの代替として使うのは目的が違う。

## believed

hexyll の開発の途中で気づいたことではない。

* どのように使うかを重視してライブラリを設計する。
  * ライブラリは使ってなんぼなので。
* 綺麗な設計をする。
  * 綺麗な設計を見つけられるまで悩もう。
* 複数の具体的な設計の間で迷ったら二つとも作る。
  * 両者を具体的に比較することで、はっきりと決定することができる。
  * 決定できなくとも、そのまま二つの設計を提供すればいい。
  * もしかしたら第三の設計を見つけられるかもしれない。
